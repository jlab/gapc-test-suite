Grammar flow types:
#CHAR_SEP (single)
#NON (single)
#SEQ (int)
ali ([spair{ (Rope first, Rope second, )}]) = [spair{ (Rope first, Rope second, )}] nil(single< single >, ) |
   [spair{ (Rope first, Rope second, )}] r(single< single >, spair{ (Rope first, Rope second, )}< [spair{ (Rope first, Rope second, )}] >, single< single >, ) |
   [spair{ (Rope first, Rope second, )}] del(single< single >, single< single >, single< single >, single< single >, spair{ (Rope first, Rope second, )}< [spair{ (Rope first, Rope second, )}] >, ) |
   [spair{ (Rope first, Rope second, )}] ins(spair{ (Rope first, Rope second, )}< [spair{ (Rope first, Rope second, )}] >, single< single >, single< single >, single< single >, single< single >, ) |
   [spair{ (Rope first, Rope second, )}] ti(single< single >, int< int >, ) |
   [spair{ (Rope first, Rope second, )}] td(int< int >, single< single >, ) |
   	# h [spair{ (Rope first, Rope second, )}]



List elimination iteration: 0

Grammar flow types:
#CHAR_SEP (single)
#NON (single)
#SEQ (int)
ali ([spair{ (Rope first, Rope second, )}]) = spair{ (Rope first, Rope second, )} nil(single< single >, ) |
   [spair{ (Rope first, Rope second, )}] r(single< single >, spair{ (Rope first, Rope second, )}< [spair{ (Rope first, Rope second, )}] >, single< single >, ) |
   [spair{ (Rope first, Rope second, )}] del(single< single >, single< single >, single< single >, single< single >, spair{ (Rope first, Rope second, )}< [spair{ (Rope first, Rope second, )}] >, ) |
   [spair{ (Rope first, Rope second, )}] ins(spair{ (Rope first, Rope second, )}< [spair{ (Rope first, Rope second, )}] >, single< single >, single< single >, single< single >, single< single >, ) |
   spair{ (Rope first, Rope second, )} ti(single< single >, int< int >, ) |
   spair{ (Rope first, Rope second, )} td(int< int >, single< single >, ) |
   	# h [spair{ (Rope first, Rope second, )}]



List elimination iteration: 1

Grammar flow types:
#CHAR_SEP (single)
#NON (single)
#SEQ (int)
ali ([spair{ (Rope first, Rope second, )}]) = spair{ (Rope first, Rope second, )} nil(single< single >, ) |
   [spair{ (Rope first, Rope second, )}] r(single< single >, spair{ (Rope first, Rope second, )}< [spair{ (Rope first, Rope second, )}] >, single< single >, ) |
   [spair{ (Rope first, Rope second, )}] del(single< single >, single< single >, single< single >, single< single >, spair{ (Rope first, Rope second, )}< [spair{ (Rope first, Rope second, )}] >, ) |
   [spair{ (Rope first, Rope second, )}] ins(spair{ (Rope first, Rope second, )}< [spair{ (Rope first, Rope second, )}] >, single< single >, single< single >, single< single >, single< single >, ) |
   spair{ (Rope first, Rope second, )} ti(single< single >, int< int >, ) |
   spair{ (Rope first, Rope second, )} td(int< int >, single< single >, ) |
   	# h [spair{ (Rope first, Rope second, )}]



List elimination iteration: 2

Grammar flow types:
#CHAR_SEP (single)
#NON (single)
#SEQ (int)
ali ([spair{ (Rope first, Rope second, )}]) = spair{ (Rope first, Rope second, )} nil(single< single >, ) |
   [spair{ (Rope first, Rope second, )}] r(single< single >, spair{ (Rope first, Rope second, )}< [spair{ (Rope first, Rope second, )}] >, single< single >, ) |
   [spair{ (Rope first, Rope second, )}] del(single< single >, single< single >, single< single >, single< single >, spair{ (Rope first, Rope second, )}< [spair{ (Rope first, Rope second, )}] >, ) |
   [spair{ (Rope first, Rope second, )}] ins(spair{ (Rope first, Rope second, )}< [spair{ (Rope first, Rope second, )}] >, single< single >, single< single >, single< single >, single< single >, ) |
   spair{ (Rope first, Rope second, )} ti(single< single >, int< int >, ) |
   spair{ (Rope first, Rope second, )} td(int< int >, single< single >, ) |
   	# h [spair{ (Rope first, Rope second, )}]



