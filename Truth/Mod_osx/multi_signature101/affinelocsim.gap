Iteration: 0
Grammar affinelocsim types:
#CHAR_SEP (char)
#SEQ (int)
alignment ([Sig answer]) = [Sig answer] nil(int< int >, ) |
   [Sig answer] del(char< char >, Sig answer< [Sig answer] >, ) |
   [Sig answer] ins(Sig answer< [Sig answer] >, char< char >, ) |
   [Sig answer] match(char< char >, Sig answer< [Sig answer] >, char< char >, ) |
   	# h [Sig answer]


skipL ([Sig answer]) = [Sig answer] sl(char< char >, Sig answer< [Sig answer] >, ) |
   [Sig answer] |
   	# h [Sig answer]


skipR ([Sig answer]) = [Sig answer] sr(Sig answer< [Sig answer] >, char< char >, ) |
   [Sig answer] |
   	# h [Sig answer]


xDel ([Sig answer]) = [Sig answer] |
   [Sig answer] delx(char< char >, Sig answer< [Sig answer] >, ) |
   	# h [Sig answer]


xIns ([Sig answer]) = [Sig answer] |
   [Sig answer] insx(Sig answer< [Sig answer] >, char< char >, ) |
   	# h [Sig answer]



Iteration: 1
Grammar affinelocsim types:
#CHAR_SEP (char)
#SEQ (int)
alignment ([Sig answer]) = [Sig answer] nil(int< int >, ) |
   [Sig answer] del(char< char >, Sig answer< [Sig answer] >, ) |
   [Sig answer] ins(Sig answer< [Sig answer] >, char< char >, ) |
   [Sig answer] match(char< char >, Sig answer< [Sig answer] >, char< char >, ) |
   	# h [Sig answer]


skipL ([Sig answer]) = [Sig answer] sl(char< char >, Sig answer< [Sig answer] >, ) |
   [Sig answer] |
   	# h [Sig answer]


skipR ([Sig answer]) = [Sig answer] sr(Sig answer< [Sig answer] >, char< char >, ) |
   [Sig answer] |
   	# h [Sig answer]


xDel ([Sig answer]) = [Sig answer] |
   [Sig answer] delx(char< char >, Sig answer< [Sig answer] >, ) |
   	# h [Sig answer]


xIns ([Sig answer]) = [Sig answer] |
   [Sig answer] insx(Sig answer< [Sig answer] >, char< char >, ) |
   	# h [Sig answer]



Return: 1
