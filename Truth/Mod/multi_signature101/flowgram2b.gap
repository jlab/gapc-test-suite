Iteration: 0
Grammar flow types:
#CHAR (char)
#EMPTY (void)
#REGION (<Input-Sub-Sequence-Type>)
#SEQ (int)
ali ([Sig answer]) = [Sig answer] nil( < void, void > <  < void, void >  >, ) |
   [Sig answer] r( < char, char > <  < char, char >  >, Sig answer< [Sig answer] >, ) |
   [Sig answer] del( < <Input-Sub-Sequence-Type>, void > < NULL >, Sig answer< [Sig answer] >, ) |
   [Sig answer] ins( < void, <Input-Sub-Sequence-Type> > < NULL >, Sig answer< [Sig answer] >, ) |
   [Sig answer] ti( < void, int > <  < void, int >  >, ) |
   [Sig answer] td( < int, void > <  < int, void >  >, ) |
   	# h [Sig answer]


gap (<Input-Sub-Sequence-Type>) = <Input-Sub-Sequence-Type> |
   

gap_1 (<Input-Sub-Sequence-Type>) = <Input-Sub-Sequence-Type> |
   


Iteration: 1
Grammar flow types:
#CHAR (char)
#EMPTY (void)
#REGION (<Input-Sub-Sequence-Type>)
#SEQ (int)
ali ([Sig answer]) = [Sig answer] nil( < void, void > <  < void, void >  >, ) |
   [Sig answer] r( < char, char > <  < char, char >  >, Sig answer< [Sig answer] >, ) |
   [Sig answer] del( < <Input-Sub-Sequence-Type>, void > <  < <Input-Sub-Sequence-Type>, void >  >, Sig answer< [Sig answer] >, ) |
   [Sig answer] ins( < void, <Input-Sub-Sequence-Type> > <  < void, <Input-Sub-Sequence-Type> >  >, Sig answer< [Sig answer] >, ) |
   [Sig answer] ti( < void, int > <  < void, int >  >, ) |
   [Sig answer] td( < int, void > <  < int, void >  >, ) |
   	# h [Sig answer]


gap (<Input-Sub-Sequence-Type>) = <Input-Sub-Sequence-Type> |
   

gap_1 (<Input-Sub-Sequence-Type>) = <Input-Sub-Sequence-Type> |
   


Iteration: 2
Grammar flow types:
#CHAR (char)
#EMPTY (void)
#REGION (<Input-Sub-Sequence-Type>)
#SEQ (int)
ali ([Sig answer]) = [Sig answer] nil( < void, void > <  < void, void >  >, ) |
   [Sig answer] r( < char, char > <  < char, char >  >, Sig answer< [Sig answer] >, ) |
   [Sig answer] del( < <Input-Sub-Sequence-Type>, void > <  < <Input-Sub-Sequence-Type>, void >  >, Sig answer< [Sig answer] >, ) |
   [Sig answer] ins( < void, <Input-Sub-Sequence-Type> > <  < void, <Input-Sub-Sequence-Type> >  >, Sig answer< [Sig answer] >, ) |
   [Sig answer] ti( < void, int > <  < void, int >  >, ) |
   [Sig answer] td( < int, void > <  < int, void >  >, ) |
   	# h [Sig answer]


gap (<Input-Sub-Sequence-Type>) = <Input-Sub-Sequence-Type> |
   

gap_1 (<Input-Sub-Sequence-Type>) = <Input-Sub-Sequence-Type> |
   


Return: 1
